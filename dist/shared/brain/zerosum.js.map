{"version":3,"sources":["zerosum.js"],"names":["npcMove","char","cx","x","cy","y","goodChoice","bestChoice","influence","human","influenceGrid","weight","dist","distanceTo","movement","realInfluence","push","curPC","i","characters","length","console","log","shortCode"],"mappings":"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","sourcesContent":["// class ZeroSumBrain {}\n/*\n\"There is a cancer eating at the Imperium. With each decade it advances deeper, leaving drained,dead worlds in its wake. This horror, this abomination, has thought and purpose which functions on an unimaginable, galactic scale and all we can do is try to stop the swarms of bio-engineered monsters it unleashes upon us by instinct. We have given the horror a name to salve our fears; we call it the Tyranid race, but if it is aware of us at all it must know us only as Prey.\"\n    â€” Inquisitor Bronislaw Czevak at the Conclave of Har\n*/\n\n// BBBBBBRRRRAAAAAAAIIIIIINNNSSSSSSS.\nfunction npcMove(char) {\n  let cx = char.x,\n    cy = char.y\n  let goodChoice = []\n  let bestChoice = { x: cx, y: cy, influence: human.influenceGrid[cy][cx] }\n  for (let y = 0; y < 16; y++) {\n    for (let x = 0; x < 16; x++) {\n      const weight = human.influenceGrid[y][x]\n      let dist = distanceTo({ x: cx, y: cy }, { x: x, y: y })\n      if (dist > char.movement) {\n        dist *= 1.5\n      }\n      const realInfluence = weight - dist\n      if (realInfluence > bestChoice.influence) {\n        goodChoice.push(bestChoice)\n        bestChoice = { x: x, y: y, influence: realInfluence }\n      }\n    }\n  }\n\n  // This is where the AI cheats a little. But you can see where everything is, so should it.\n  let dist = 0\n  let curPC = 0\n  for (let i = 0; i < human.characters.length; i++) {\n    curPC = i\n    //Find each PC on the grid, if distanceTo = 1 attack at its x, y.\n    dist = distanceTo(\n      { x: cx, y: cy },\n      { x: human.characters[curPC].x, y: human.characters[curPC].y }\n    )\n    if (dist == 1) {\n      //pass attack function @ human.characters[curPC]\n    }\n  }\n // if we cannot attack then we need to check for moves\n  if (cy != bestChoice.y) {\n    if (cx != bestChoice.x) {\n      // add a distance check to PC's if greater than 1\n      // move to bestChoice.y, bestChoice.x\n      console.log(\"MOVE ME\")\n    }\n  }\n  if (cy == bestChoice.y) {\n    if (cx == bestChoice.x) {\n      // console.log(\"I AM STUCK\")\n      // Hack move for the time being, it's not stupid if it works. \n      bestChoice = { x: cx + 7, y: cy }\n      // pass moveTo(char) function here with bestChoice.y, bestChoice.x\n    }\n  }\n\n  console.log(char.shortCode, \"x=\", cx, \"y=\", cy)\n  console.log(\"Our best choice so far seems to be\", bestChoice)\n}\n"]}