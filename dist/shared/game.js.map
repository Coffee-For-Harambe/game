{"version":3,"sources":["game.js"],"names":["Team","Character","buildGrid","Game","constructor","state","teamsTurn","selectedCharacter","turnStage","teams","Rogue","Monk","Ranger","Warrior","Wizard","Skeleton","Dragon","forEach","team","setGame","update","getCharacterGrid","grid","characters","c","y","x","getOpposingTeam","resetTurnState","Instance","_Instance","window","GAME","advanceTurn","length","console","log","getActiveTeam","getActiveTurnStage","characterGrid","renderer","squareClicked","square","clicked","selected","canReach","moveSprite","canAttack","potentialEnemy","canReachAttack","pos","attack","alert","confirm"],"mappings":"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","sourcesContent":["import Team from \"./team\"\nimport Character from \"./character\"\nimport { buildGrid } from \"./gridutils\"\n\nexport default class Game {\n  constructor() {\n    this.state = {\n      teamsTurn: 0,\n      selectedCharacter: null,\n      turnStage: \"Moving\",\n    }\n\n    this.teams = []\n    this.teams[0] = new Team([\n      new Character.Rogue(1, 15),\n      new Character.Monk(4, 15),\n      new Character.Ranger(7, 15),\n      new Character.Warrior(10, 15),\n      new Character.Wizard(13, 15),\n    ])\n\n    this.teams[1] = new Team([\n      new Character.Skeleton(0, 0),\n      new Character.Skeleton(3, 13),\n      new Character.Skeleton(7, 0),\n      new Character.Dragon(9, 0),\n\n      new Character.Skeleton(13, 0),\n      new Character.Skeleton(15, 0),\n    ])\n\n    this.teams.forEach((team) => {\n      team.setGame(this)\n    })\n\n    this.update()\n  }\n\n  getCharacterGrid() {\n    const grid = buildGrid()\n    this.teams.forEach((team) => {\n      team.characters.forEach((c) => {\n        grid[c.y][c.x] = c\n      })\n    })\n\n    return grid\n  }\n\n  // createInitialState() {}\n\n  getOpposingTeam(team) {\n    if (team == this.teams[0]) {\n      return this.teams[1]\n    } else if (team == this.teams[1]) {\n      return this.teams[0]\n    }\n  }\n\n  resetTurnState() {\n    this.state.selectedCharacter = null\n    this.state.turnStage = \"Moving\"\n  }\n\n  static _Instance = null\n  static get Instance() {\n    if (!Game._Instance) {\n      Game._Instance = new Game()\n      window.GAME = Game._Instance\n    }\n\n    return Game._Instance\n  }\n\n  advanceTurn() {\n    this.state.teamsTurn = (this.state.teamsTurn + 1) % this.teams.length\n    console.log(\"Next teams turn\")\n    this.resetTurnState()\n    this.update()\n  }\n\n  getActiveTeam() {\n    return this.teams[this.state.teamsTurn]\n  }\n\n  getActiveTurnStage() {\n    return this.teams[this.state.turnStage]\n  }\n\n  update() {\n    this.teams.forEach((team) => team.update())\n    this.characterGrid = this.getCharacterGrid()\n    if (this.renderer) {\n      this.renderer.update()\n    }\n  }\n\n  // export function distanceTo(v1, v2) {\n  //   let distance = v2.y - v1.y + (v2.x - v2.x)\n  //   return distance\n  // }\n\n  squareClicked(square) {\n    let x, y\n    let clicked\n\n    const state = this.state\n    const selected = state.selectedCharacter\n\n    if (square) {\n      x = square.x\n      y = square.y\n      clicked = this.characterGrid[y][x]\n    }\n\n    if (state.turnStage == \"Moving\") {\n      if (clicked && clicked.team == this.getActiveTeam()) {\n        state.selectedCharacter = clicked\n      } else if (selected !== null) {\n        if (square == null) {\n          state.selectedCharacter = null\n        } else {\n          if (selected.canReach(square)) {\n            if (!clicked) {\n              selected.moveSprite(square)\n\n              let canAttack = false\n              for (let potentialEnemy of selected.getOpposingTeam().characters) {\n                if (selected.canReachAttack(potentialEnemy.pos)) {\n                  canAttack = true\n                  break\n                }\n              }\n\n              if (canAttack) {\n                state.turnStage = \"Attacking\"\n              } else {\n                this.advanceTurn()\n              }\n            } else if (selected.canReachAttack(square)) {\n              selected.attack(clicked)\n              this.advanceTurn()\n            }\n          } else {\n            alert(\"You can't reach that\")\n          }\n        }\n      }\n    } else if (state.turnStage == \"Attacking\") {\n      if (!square || !clicked || clicked.team == this.getActiveTeam()) {\n        if (confirm(\"Are you sure you want to end your turn without attacking?\")) {\n          this.advanceTurn()\n        }\n      } else {\n        if (selected.canReachAttack(square)) {\n          selected.attack(clicked)\n          this.advanceTurn()\n        } else {\n          alert(\"You wiff, Serr! Your attacks can't reach that! :(\")\n        }\n      }\n    }\n\n    //RESET STATE//\n  }\n}\n"]}