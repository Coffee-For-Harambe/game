{"version":3,"sources":["astar.js"],"names":["Game","Vector2","Node","constructor","x","y","g","Infinity","h","pos","obj","equals","other","findGraphNode","node","i","closedList","length","isWall","neighbor","Instance","characterGrid","computePath","start","end","char","heuristic","grid","openList","push","lowInd","f","currentNode","curr","ret","parent","reverse","splice","neighbors","getNeighbors","isInClosed","gScore","gScoreIsBest","preExisting","debug","window","pos0","pos1","d1","Math","abs","d2"],"mappings":"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","sourcesContent":["import Game from \"./game\"\nimport { Vector2 } from \"three\"\n\nclass Node {\n  constructor(x, y, g = Infinity, h = Infinity) {\n    this.x = x\n    this.y = y\n    this.g = g\n    this.h = h\n  }\n\n  get pos() {\n    return { x: this.x, y: this.y }\n  }\n\n  set pos(obj) {\n    this.x = obj.x\n    this.y = obj.y\n  }\n\n  // get f() {\n  //   this.g + this.h\n  // }\n\n  equals(other) {\n    return this.x == other.x && this.y == other.y\n  }\n}\n\n//search closedlist for node, return truthy if present\nfunction findGraphNode(node) {\n  for (i = 0; i < closedList.length; i++) {\n    if (closedList[i] == node) {\n      break\n    }\n  }\n}\n//callout tiles we can't move on\nfunction isWall(neighbor) {\n  if (\n    neighbor.y == 16 ||\n    neighbor.x == 16 ||\n    neighbor.y == 0 ||\n    neighbor.x == 0 ||\n    Game.Instance.characterGrid[y][x] != 0\n  ) {\n    true\n  }\n}\n\nexport function computePath(start, end, char) {\n  start = new Node(start.x, start.y, 0, heuristic(start, end))\n  end = new Node(end.x, end.y)\n\n  const grid = Game.Instance.characterGrid\n\n  let openList = []\n  let closedList = []\n  openList.push(start)\n\n  while (openList.length > 0) {\n    // Grab the lowest f(x) to process next\n    let lowInd = 0\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].f < openList[lowInd].f) {\n        lowInd = i\n      }\n    }\n\n    let currentNode = openList[lowInd]\n\n    // end case -- result has been found, return the traced path\n    if (currentNode.equals(end)) {\n      let curr = currentNode\n      let ret = []\n      while (curr.parent) {\n        ret.push(new Vector2(curr.x, curr.y))\n        curr = curr.parent\n      }\n      return ret.reverse()\n    }\n\n    // Normal case -- move currentNode from open to closed, process each of its neighbors\n    openList.splice(lowInd, 1)\n    closedList.push(currentNode)\n\n    let neighbors = getNeighbors(grid, currentNode, char)\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i]\n\n      let isInClosed = false\n      for (let i = 0; i < closedList.length; i++) {\n        if (neighbor.equals(closedList[i])) {\n          isInClosed = true\n          break\n        }\n      }\n\n      if (isInClosed) {\n        continue\n      }\n\n      // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbor is the shortest one we have seen yet\n      let gScore = currentNode.g + 1 // 1 is the distance from a node to it's neighbor\n      let gScoreIsBest = false\n\n      let preExisting = null\n      for (let i = 0; i < openList.length; i++) {\n        if (neighbor.equals(openList[i])) {\n          neighbor = openList[i]\n          preExisting = true\n          break\n        }\n      }\n\n      if (!preExisting) {\n        //rewrite this\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n\n        gScoreIsBest = true\n        neighbor.h = heuristic(neighbor.pos, end.pos)\n        openList.push(neighbor)\n      } else if (gScore < neighbor.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbor.parent = currentNode\n        neighbor.g = gScore\n        neighbor.f = neighbor.g + neighbor.h\n        neighbor.debug = \"F: \" + neighbor.f + \"<br />G: \" + neighbor.g + \"<br />H: \" + neighbor.h\n      }\n    }\n  }\n\n  // No result was found -- empty array signifies failure to find path\n  return []\n}\n\nwindow.computePath = computePath\n\nfunction heuristic(pos0, pos1) {\n  // This is the Manhattan distance\n  let d1 = Math.abs(pos1.x - pos0.x)\n  let d2 = Math.abs(pos1.y - pos0.y)\n  return d1 + d2\n}\n\nfunction getNeighbors(grid, node, char) {\n  let ret = []\n  let x = node.x\n  let y = node.y\n\n  if (y - 1 > 0 && grid[y - 1] && (grid[y - 1][x] == 0 || grid[y - 1][x] == char)) {\n    ret.push(new Node(x, y - 1))\n  }\n\n  if (y + 1 < 15 && grid[y + 1] && (grid[y + 1][x] == 0 || grid[y + 1][x] == char)) {\n    ret.push(new Node(x, y + 1))\n  }\n\n  if (x - 1 > 0 && (grid[y][x - 1] == 0 || grid[y][x - 1] == char)) {\n    ret.push(new Node(x - 1, y))\n  }\n\n  if (x + 1 < 15 && (grid[y][x + 1] == 0 || grid[y][x + 1] == char)) {\n    ret.push(new Node(x + 1, y))\n  }\n\n  return ret\n}\n"]}