{"version":3,"sources":["astar.js"],"names":["getCharacterGrid","Game","buildGrid","astar","constructor","grid","start","end","init","removeGraphNode","node","openList","currentNode","closedList","push","findGraphNode","i","length","isWall","neighbor","y","x","teams","search","lowInd","f","pos","curr","ret","parent","reverse","neighbors","gScore","g","gScoreIsBest","h","heuristic","debug","pos0","pos1","d1","Math","abs","d2"],"mappings":"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","sourcesContent":["import getCharacterGrid from \"./team\"\nimport Game from \"./game\"\nimport { buildGrid } from \"./gridutils\"\n\nexport default class astar {\n  constructor(grid, start, end) {\n    //(buildGrid(), selectedCharacter(S), square(E))\n    this.grid = grid\n    this.start = start\n    this.end = end\n  }\n\n  init(grid) {\n    grid = buildGrid()\n  }\n  //remove the node from openlist, add it to closedList\n  removeGraphNode(node) {\n    for (node in openList) {\n      if (node == currentNode) closedList.push(node)\n    }\n  }\n  //search closedlist for node, return truthy if present\n  findGraphNode(node) {\n    for (i = 0; i < closedList.length; i++) {\n      if (closedList[i] == node) {\n        break\n      }\n    }\n  }\n  //callout tiles we can't move on\n  isWall(neighbor) {\n    if (\n      neighbor.y == 16 ||\n      neighbor.x == 16 ||\n      neighbor.y == 0 ||\n      neighbor.x == 0 ||\n      neighbor == getCharacterGrid(Game.teams)\n    ) {\n      true\n    }\n  }\n\n  search(grid, start, end) {\n    astar.init()\n\n    let openList = []\n    let closedList = []\n    openList.push(start)\n\n    while (openList.length > 0) {\n      // Grab the lowest f(x) to process next\n      let lowInd\n      for (let i = 0; i < openList.length; i++) {\n        if (openList[i].f < openList[lowInd].f) {\n          lowInd = i\n        }\n      }\n      let currentNode = openList[lowInd]\n\n      // end case -- result has been found, return the traced path\n      if (currentNode.pos == end.pos) {\n        let curr = currentNode\n        let ret = []\n        while (curr.parent) {\n          ret.push(curr)\n          curr = curr.parent\n        }\n        return ret.reverse()\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors\n      openList.removeGraphNode(currentNode) //REWRITE THIS TO TAKE CURRENT NODE OUT OF OPENLIST\n      closedList.push(currentNode)\n      let neighbors = astar.neighbors(grid, currentNode)\n\n      for (let i = 0; i < neighbors.length; i++) {\n        let neighbor = neighbors[i]\n        if (closedList.findGraphNode(neighbor) || neighbor.isWall()) {\n          //REWRITE THIS TO TAKE OUT EXCEPTIONS TO NODE PROCESS (ENEMIES, ALLIES, ETC.)\n          // not a valid node to process, skip to next neighbor\n          continue\n        }\n\n        // g score is the shortest distance from start to current node, we need to check if\n        //   the path we have arrived at this neighbor is the shortest one we have seen yet\n        let gScore = currentNode.g + 1 // 1 is the distance from a node to it's neighbor\n        let gScoreIsBest = false\n\n        if (!openList.findGraphNode(neighbor)) {\n          //rewrite this\n          // This the the first time we have arrived at this node, it must be the best\n          // Also, we need to take the h (heuristic) score since we haven't done so yet\n\n          gScoreIsBest = true\n          neighbor.h = astar.heuristic(neighbor.pos, end.pos)\n          openList.push(neighbor)\n        } else if (gScore < neighbor.g) {\n          // We have already seen the node, but last time it had a worse g (distance from start)\n          gScoreIsBest = true\n        }\n\n        if (gScoreIsBest) {\n          // Found an optimal (so far) path to this node.   Store info on how we got here and\n          //  just how good it really is...\n          neighbor.parent = currentNode\n          neighbor.g = gScore\n          neighbor.f = neighbor.g + neighbor.h\n          neighbor.debug = \"F: \" + neighbor.f + \"<br />G: \" + neighbor.g + \"<br />H: \" + neighbor.h\n        }\n      }\n    }\n\n    // No result was found -- empty array signifies failure to find path\n    return []\n  }\n\n  heuristic(pos0, pos1) {\n    // This is the Manhattan distance\n    let d1 = Math.abs(pos1.x - pos0.x)\n    let d2 = Math.abs(pos1.y - pos0.y)\n    return d1 + d2\n  }\n\n  neighbors(grid, node) {\n    let ret = []\n    let x = node.pos.x\n    let y = node.pos.y\n\n    if (grid[x - 1] && grid[x - 1][y]) {\n      ret.push(grid[x - 1][y])\n    }\n    if (grid[x + 1] && grid[x + 1][y]) {\n      ret.push(grid[x + 1][y])\n    }\n    if (grid[x][y - 1] && grid[x][y - 1]) {\n      ret.push(grid[x][y - 1])\n    }\n    if (grid[x][y + 1] && grid[x][y + 1]) {\n      ret.push(grid[x][y + 1])\n    }\n    return ret\n  }\n}\n"]}